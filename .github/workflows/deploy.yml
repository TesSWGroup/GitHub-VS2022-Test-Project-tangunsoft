# 워크플로의 이름을 정의합니다. 이 이름은 GitHub의 Actions 탭에서 표시됩니다.
name: GitHub Actions 실행시켜보기

# 워크플로우가 실행될 조건을 지정합니다.
on:
  # main 브랜치에 push가 발생할 때 실행됩니다.
  push:
    branches:
      - main
  # main 브랜치로 pull request가 생성되거나 업데이트될 때 실행됩니다.
  pull_request:
    branches:
      - main

# 실제로 실행될 작업들을 정의합니다.
jobs:
  # 'Build-And-Analysis'라는 이름의 작업을 정의합니다.
  # 이 작업은 빌드와 다양한 코드 분석을 수행합니다.
  Build-And-Analysis:
    # Windows 최신 버전의 가상 환경에서 실행합니다.
    # Visual Studio 2022와 관련 도구들이 미리 설치되어 있습니다.
    runs-on: windows-latest

    # GitHub Actions가 필요로 하는 권한들을 설정합니다.
    permissions:
      actions: read      # GitHub Actions의 실행 권한
      contents: read     # 저장소 내용을 읽을 수 있는 권한
      security-events: write  # 보안 검사 결과를 쓸 수 있는 권한

    # 순차적으로 실행될 단계들을 정의합니다.
    steps:
      # Step 1: 저장소 코드를 가져옵니다.
      - name: 저장소 체크아웃
        uses: actions/checkout@v3
        # 이 단계는 현재 저장소의 코드를 가상 환경으로 복사합니다.

      # Step 2: 기본 동작 테스트를 위한 Hello World 출력
      - name: Hello World 출력
        run: echo "Hello World"
        # 워크플로우가 정상적으로 실행되는지 확인하기 위한 기본 테스트입니다.

      # Step 3: 여러 줄의 명령어 실행 테스트
      - name: 여러 명령어 실행
        run: |
          echo "Hello World"
          echo "Good "
          echo "Morning"
        # 파이프라인(|)을 사용하여 여러 줄의 명령어를 실행하는 예제입니다.

      # Step 4: GitHub에서 제공하는 환경 변수 출력
      - name: GitHub Actions 변수 출력
        run: |
          echo "Repository: %GITHUB_REPOSITORY%"
          echo "SHA: %GITHUB_SHA%"
        shell: cmd
        # GitHub Actions에서 기본으로 제공하는 환경 변수들을 확인합니다.

      # Step 5: GitHub Secrets에 저장된 비밀 값 출력
      - name: GitHub Actions 비밀변수 출력
        env:
          MY_NAME: ${{ secrets.MY_NAME }}     # GitHub Secrets에 저장된 MY_NAME 값
          MY_HOBBY: ${{ secrets.MY_HOBBY }}   # GitHub Secrets에 저장된 MY_HOBBY 값
        run: |
          echo "Secret: %MY_NAME%"
          echo "Secret: %MY_HOBBY%"
        shell: cmd
        # 민감한 정보를 안전하게 사용하는 방법을 보여줍니다.

      # Step 6: Cppcheck 도구 다운로드 및 설치
      - name: Cppcheck 설치
        run: |
          # Cppcheck 최신 버전 다운로드 (2.13.0 버전 사용)
          $url = "https://github.com/danmar/cppcheck/releases/download/2.13.0/cppcheck-2.13.0-x64-Setup.msi"
          $output = "cppcheck-setup.msi"
          
          # 다운로드
          Write-Host "Downloading Cppcheck..."
          Invoke-WebRequest -Uri $url -OutFile $output
          
          # 자동 설치 실행
          Write-Host "Installing Cppcheck..."
          Start-Process msiexec.exe -Wait -ArgumentList "/i $output /quiet"
          
          # 설치 확인
          Write-Host "Verifying installation..."
          $env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")
          $cppcheckPath = "C:\Program Files\Cppcheck"
          if (Test-Path "$cppcheckPath\cppcheck.exe") {
              Write-Host "Cppcheck installed successfully"
          } else {
              Write-Error "Cppcheck installation failed"
              exit 1
          }
        shell: pwsh
        # MSI 설치 파일을 직접 다운로드하여 설치합니다.

      # Step 7: Cppcheck를 사용한 정적 코드 분석 실행
      - name: Cppcheck 정적 분석
        run: |
          # Cppcheck 실행 경로 설정
          set PATH=C:\Program Files\Cppcheck;%PATH%
          
          REM Cppcheck 실행 (일반 텍스트와 XML 형식으로 동시 출력)
          "C:\Program Files\Cppcheck\cppcheck.exe" ^
          --enable=all ^
          --suppress=missingInclude ^
          --inline-suppr ^
          --inconclusive ^
          --std=c++17 ^
          --output-file=cppcheck_report.txt ^
          --template="{file}:{line}:{column}: {severity}:{id}:{message}" ^
          --xml --xml-version=2 --output-file=cppcheck-results.xml ^
          .
        shell: cmd
        # 일반 텍스트 결과와 함께 XML 형식의 결과도 생성합니다.

      # [수정된 부분 시작] - SARIF 변환 스크립트 개선
      - name: Cppcheck 결과를 SARIF로 변환
        run: |
          # SARIF 변환 스크립트 실행
          Add-Type -AssemblyName System.Web
          
          # XML 파일 읽기
          $xml = [xml](Get-Content "cppcheck-results.xml")
          
          # SARIF 객체 생성 (필수 필드 추가)
          $sarif = @{
              '$schema' = "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json"
              version = "2.1.0"
              runs = @(
                  @{
                      tool = @{
                          driver = @{
                              name = "Cppcheck"
                              version = "2.13.0"  # 버전 정보 추가
                              informationUri = "https://cppcheck.sourceforge.io"  # 도구 정보 추가
                              rules = @()  # 규칙 정보 저장소
                          }
                      }
                      results = @()
                      invocations = @(  # 실행 정보 추가
                          @{
                              executionSuccessful = $true
                              toolExecutionNotifications = @()
                          }
                      )
                  }
              )
          }

          # 규칙 정보 수집 및 추가
          $uniqueRules = @{}
          foreach ($error in $xml.results.errors.error) {
              if (-not $uniqueRules.ContainsKey($error.id)) {
                  $uniqueRules[$error.id] = @{
                      id = $error.id
                      name = $error.id
                      shortDescription = @{
                          text = $error.msg
                      }
                      fullDescription = @{
                          text = $error.verbose
                      }
                      defaultConfiguration = @{
                          level = if ($error.severity -eq "error") { "error" } else { "warning" }
                      }
                  }
              }
          }
          $sarif.runs[0].tool.driver.rules = $uniqueRules.Values

          # 분석 결과 변환
          foreach ($error in $xml.results.errors.error) {
              # 파일 경로 정규화
              $filePath = $error.location.file.Replace("\", "/")
              if ($filePath.StartsWith("./")) {
                  $filePath = $filePath.Substring(2)
              }
              
              $result = @{
                  ruleId = $error.id
                  level = if ($error.severity -eq "error") { "error" } else { "warning" }
                  message = @{
                      text = $error.verbose
                  }
                  locations = @(
                      @{
                          physicalLocation = @{
                              artifactLocation = @{
                                  uri = [System.Web.HttpUtility]::UrlPathEncode($filePath)
                                  uriBaseId = "%SRCROOT%"
                              }
                              region = @{
                                  startLine = [int]$error.location.line
                                  startColumn = 1
                                  endColumn = if ($error.location.column) { [int]$error.location.column } else { 80 }
                              }
                          }
                      }
                  )
                  partialFingerprints = @{
                      primaryLocationLineHash = "$filePath:$($error.location.line)"
                  }
              }
              $sarif.runs[0].results += $result
          }

          # SARIF 파일 저장 (UTF-8, BOM 없음)
          $utf8NoBOM = New-Object System.Text.UTF8Encoding $false
          [System.IO.File]::WriteAllText(
              "cppcheck-results.sarif",
              (ConvertTo-Json -InputObject $sarif -Depth 10),
              $utf8NoBOM
          )
          
          # 저장된 파일 확인
          if (Test-Path "cppcheck-results.sarif") {
              Write-Host "SARIF file created successfully"
              Get-Content "cppcheck-results.sarif" | Select-Object -First 10
          } else {
              Write-Error "Failed to create SARIF file"
              exit 1
          }
        shell: pwsh
        # Cppcheck XML 결과를 GitHub Code Scanning이 이해할 수 있는 SARIF 형식으로 변환합니다.
        # 개선된 버전은 더 자세한 규칙 정보와 위치 정보를 포함합니다.
      # [수정된 부분 끝]

      # [수정된 부분 시작] - SARIF 업로드 개선
      - name: SARIF 결과 업로드
        uses: github/codeql-action/upload-sarif@v3
        if: always()  # 이전 단계가 실패해도 실행
        with:
          sarif_file: cppcheck-results.sarif
          category: Cppcheck
          wait-for-processing: true  # 처리 완료까지 대기
      # [수정된 부분 끝]

      # Step 10: Cppcheck 분석 결과를 아티팩트로 저장
      - name: Cppcheck 결과 저장
        if: always()  # 이전 단계가 실패해도 실행
        run: |
          if exist cppcheck_report.txt (
            type cppcheck_report.txt
            mkdir artifacts
            copy cppcheck_report.txt artifacts\
            copy cppcheck-results.xml artifacts\
            copy cppcheck-results.sarif artifacts\
            echo "Cppcheck 분석 결과가 저장되었습니다."
          ) else (
            echo "Warning: Cppcheck 결과 파일을 찾을 수 없습니다."
          )
        shell: cmd
        # 모든 결과 파일을 아티팩트로 저장합니다.

      # Step 11: CodeQL 분석 준비
      - name: CodeQL 초기화
        uses: github/codeql-action/init@v3
        with:
          languages: cpp    # C++ 언어 분석 설정
        # GitHub의 강력한 코드 분석 도구인 CodeQL을 초기화합니다.

      # Step 12: Visual Studio를 사용한 프로젝트 빌드
      - name: Visual Studio 프로젝트 빌드
        run: |
          # Visual Studio의 MSBuild 도구 경로를 찾습니다.
          $msbuildPath = & "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe" `
            -latest -products * -requires Microsoft.Component.MSBuild -find MSBuild\**\Bin\MSBuild.exe
          # 프로젝트를 Release 모드로 빌드합니다.
          & "$msbuildPath" GitHub_VS2022_Test_Project.sln /p:Configuration=Release
        shell: pwsh
        # Visual Studio 프로젝트를 빌드하고, 이 과정에서 CodeQL이 코드를 분석합니다.

      # Step 13: CodeQL 분석 실행
      - name: CodeQL 분석 실행
        uses: github/codeql-action/analyze@v3
        # 빌드 중 수집된 데이터를 바탕으로 보안 취약점을 분석합니다.
        # 결과는 GitHub의 Security 탭에서 확인할 수 있습니다.
